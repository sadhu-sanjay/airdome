

<div id="map"></div>

<div style="display: none">
  <input
  style="padding: 1rem; margin: 1rem"
    id="pac-input"
    class="controls"
    type="text"
    placeholder="Enter a location"
  />
</div>

<style>
  #map {
    height: 100vh; /* Full viewport height */
    width: 100%;
  }

  button {
    margin: 5px;
    padding: 8px 12px;
    font-size: 14px;
  }

  .controls {
    background-color: #fff;
    border-radius: 2px;
    border: 1px solid transparent;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    box-sizing: border-box;
    font-family: Roboto;
    font-size: 15px;
    font-weight: 300;
    height: 29px;
    margin-left: 17px;
    margin-top: 10px;
    outline: none;
    padding: 0 11px 0 13px;
    text-overflow: ellipsis;
    width: 400px;
  }

  .controls:focus {
    border-color: #4d90fe;
  }
</style>
<script is:inline>
  let map;
  let polygon;
  let widthMarker, heightMarker, rotationMarker;
  let topLeft; // Fixed reference point
  let width = 200; // Width in meters
  let height = 100; // Height in meters
  let rotation = 90; // Rotation in degrees (0Â° = north)

  // Initial center (San Francisco)
  const initialCenter = { lat: 37.7749, lng: -122.4194 };

  async function initMap() {
    // Import required libraries
    const [{ Map }, { Marker }] = await Promise.all([
      google.maps.importLibrary("maps"),
      google.maps.importLibrary("marker"),
      google.maps.importLibrary("places"),
      google.maps.importLibrary("geometry"),
    ]);

    // Initialize the 2D map
    map = new Map(document.getElementById("map"), {
      center: initialCenter,
      zoom: 17,
      mapId: "4504f8b37365c3d0", // Replace with your Map ID
      mapTypeId: google.maps.MapTypeId.SATELLITE,
      streetViewControl: false,
      fullscreenControl: false,
      tilt: 0,
      mapTypeControlOptions: {
        position: google.maps.ControlPosition.TOP_RIGHT,
      },
    });
    await initAutoComplete();

    topLeft = google.maps.geometry.spherical.computeOffset(
      map.getCenter(),
      width / 2,
      rotation - 90
    );

    updateRectangle();

    // Add drag event listener to polygon
    polygon.addListener("drag", () => {
      const path = polygon.getPath();
      topLeft = path.getAt(0);
      updateRectangle();
      updateOtherMarkers();
    });

    // Width marker at right edge midpoint
    widthMarker = new Marker({
      position: getRightEdgeMidpoint(),
      map: map,
      draggable: true,
      title: "Width (Drag to Resize)",
      icon: {
        url: "/icons/scale-width.svg",
        anchor: new google.maps.Point(16, 16),
      },
    });

    // Height marker at bottom edge midpoint
    heightMarker = new Marker({
      position: getBottomEdgeMidpoint(),
      map: map,
      draggable: true,
      title: "Height (Drag to Resize)",
      icon: {
        url: "/icons/scale.svg",
        anchor: new google.maps.Point(0, 16),
        labelOrigin: new google.maps.Point(15, 40),
      },
    });

    // Rotation marker near bottom-right corner
    rotationMarker = new Marker({
      position: getRotationMarkerPosition(),
      map: map,
      draggable: true,
      title: "Rotation (Drag to Rotate)",
      icon: {
        url: "/icons/rotate.svg",
        anchor: new google.maps.Point(-26, -26),
      },
    });

    // Rotation handling
    let initialHeading;
    rotationMarker.addListener("dragstart", () => {
      const currentPos = rotationMarker.getPosition();
      initialHeading = google.maps.geometry.spherical.computeHeading(
        topLeft,
        currentPos
      );
    });

    rotationMarker.addListener("drag", () => {
      const p = rotationMarker.getPosition();
      const newHeading = google.maps.geometry.spherical.computeHeading(
        topLeft,
        p
      );
      const deltaRotation = newHeading - initialHeading;
      rotation += deltaRotation;
      initialHeading = newHeading;
      updateRectangle();
      updateOtherMarkers("");
    });

    // Width adjustment (keeps left edge fixed)
    widthMarker.addListener("drag", () => {
      const p = widthMarker.getPosition();
      const distance = google.maps.geometry.spherical.computeDistanceBetween(
        topLeft,
        p
      );
      const heading = google.maps.geometry.spherical.computeHeading(topLeft, p);
      const angleDiff = ((heading - rotation) * Math.PI) / 180;
      const projection = distance * Math.cos(angleDiff);

      if (projection > 10) {
        width = projection;
        updateRectangle();
        updateOtherMarkers("");
      }
    });

    // Height adjustment (keeps top edge fixed)
    heightMarker.addListener("drag", () => {
      const p = heightMarker.getPosition();
      const distance = google.maps.geometry.spherical.computeDistanceBetween(
        topLeft,
        p
      );
      const heading = google.maps.geometry.spherical.computeHeading(topLeft, p);
      const angleDiff = ((heading - (rotation + 90)) * Math.PI) / 180;
      const projection = distance * Math.cos(angleDiff);

      if (projection > 10) {
        height = projection;
        updateRectangle();
        updateOtherMarkers("");
      }
    });
  }

  /**
   * Updates the rectangle's corners based on topLeft, width, height, and rotation.
   */
  function updateRectangle() {
    const topRight = google.maps.geometry.spherical.computeOffset(
      topLeft,
      width,
      rotation
    );
    const bottomLeft = google.maps.geometry.spherical.computeOffset(
      topLeft,
      height,
      rotation + 90
    );
    const bottomRight = google.maps.geometry.spherical.computeOffset(
      topRight,
      height,
      rotation + 90
    );
    const corners = [topLeft, topRight, bottomRight, bottomLeft];
    if (!polygon) {
      polygon = new google.maps.Polygon({
        paths: corners,
        map: map,
        strokeColor: "#FF0000",
        fillColor: "#FF0000",
        fillOpacity: 0.15,
        strokeWeight: 2,
        draggable: true,
      });
    } else {
      polygon.setPath(corners);
    }

    debouncer(sendEvent, 500)();
  }

  /**
   * Updates the positions of markers unless excluded.
   * @param {string} exclude - The marker type to exclude from updating.
   */
  function updateOtherMarkers(exclude) {
    if (exclude !== "width") {
      widthMarker.setPosition(getRightEdgeMidpoint());
    }
    if (exclude !== "height") {
      heightMarker.setPosition(getBottomEdgeMidpoint());
    }
    if (exclude !== "rotation") {
      rotationMarker.setPosition(getRotationMarkerPosition());
    }
  }

  /**
   * Computes the top-right corner.
   * @returns {google.maps.LatLng}
   */
  function getTopRight() {
    return google.maps.geometry.spherical.computeOffset(
      topLeft,
      width,
      rotation
    );
  }

  /**
   * Computes the bottom-left corner.
   * @returns {google.maps.LatLng}
   */
  function getBottomLeft() {
    return google.maps.geometry.spherical.computeOffset(
      topLeft,
      height,
      rotation + 90
    );
  }

  /**
   * Computes the bottom-right corner.
   * @returns {google.maps.LatLng}
   */
  function getBottomRight() {
    return google.maps.geometry.spherical.computeOffset(
      getTopRight(),
      height,
      rotation + 90
    );
  }

  /**
   * Computes the midpoint of the right edge for the width marker.
   * @returns {google.maps.LatLng}
   */
  function getRightEdgeMidpoint() {
    const topRight = getTopRight();
    const bottomRight = getBottomRight();
    return google.maps.geometry.spherical.interpolate(
      topRight,
      bottomRight,
      0.5
    );
  }

  /**
   * Computes the midpoint of the bottom edge for the height marker.
   * @returns {google.maps.LatLng}
   */
  function getBottomEdgeMidpoint() {
    const bottomLeft = getBottomLeft();
    const bottomRight = getBottomRight();
    return google.maps.geometry.spherical.interpolate(
      bottomLeft,
      bottomRight,
      0.5
    );
  }

  /**
   * @returns {google.maps.LatLng}
   */
  function getPolygonCenter() {
    return google.maps.geometry.spherical.interpolate(
      topLeft,
      getBottomRight(),
      0.5
    );
  }

  /**
   * Computes the position of the rotation marker (at bottom-right).
   * @returns {google.maps.LatLng}
   */
  function getRotationMarkerPosition() {
    return getBottomRight();
  }

  /**
   * send event with polygon data
   * @returns {void}
   */

  function sendEvent() {
    const path = polygon.getPath().getArray();
    const areaM2 = google.maps.geometry.spherical.computeArea(path);
    const areaFt2 = areaM2 * 10.7639;
    const coords = path
      .map((point) => `(${point.lat().toFixed(6)}, ${point.lng().toFixed(6)})`)
      .join("\n");

    const polygonData = {
      center: getPolygonCenter().toJSON(),
      coordinates: polygon.getPath().getArray(),
      area: areaFt2.toFixed(2),
    };

    // Dispatch an event with the data
    document.dispatchEvent(
      new CustomEvent("polygonUpdated", { detail: polygonData })
    );
  }

  function listenForPlaceChange() {
    document.addEventListener("placeChanged", (event) => {
      const place = event.detail;
      const newCenter = place.geometry.location;

      map.panTo(newCenter);
      topLeft = newCenter;
      updateRectangle();
      updateOtherMarkers();
    });
  }

  async function initAutoComplete() {
    const input = document.getElementById("pac-input");
    // Specify just the place data fields that you need.
    const autocomplete = new google.maps.places.Autocomplete(input, {
      fields: ["place_id", "geometry", "formatted_address", "name"],
    });

    autocomplete.bindTo("bounds", map);
    map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);

    autocomplete.addListener("place_changed", () => {

      const place = autocomplete.getPlace();

      if (!place.geometry || !place.geometry.location) {
        return;
      }

      if (place.geometry.viewport) {
        map.fitBounds(place.geometry.viewport);
      } else {
        map.setCenter(place.geometry.location);
        map.setZoom(17);
      }

      topLeft = google.maps.geometry.spherical.computeOffset(
        place.geometry.location,
        width / 2,
        rotation - 90
      );

      updateRectangle();
      updateOtherMarkers();

    });
  }

  function debouncer(fn, delay) {
    let timer;
    return function () {
      const context = this;
      const args = arguments;
      clearTimeout(timer);
      timer = setTimeout(() => {
        fn.apply(context, args);
      }, delay);
    };
  }

  initMap();
  listenForPlaceChange();
</script>
